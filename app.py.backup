from flask import Flask, request, jsonify
from flask_cors import CORS
import logging
import os
from datetime import datetime
import traceback
from config.config import Config

# Import our classes
from models.category_manager import CategoryManager
from utils.database_manager import DatabaseManager
from models.hybrid_recommender import HybridRecommender

# Configuration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)
recommender = None
db_manager = None

app = Flask(__name__)
CORS(app)

# Configuration from environment or defaults
MONGO_URI = os.getenv('MONGO_URI', 'mongodb://localhost:27017/')
MONGO_DB = os.getenv('MONGO_DB', 'recommendation_db')
GORSE_API_URL = os.getenv('GORSE_API_URL', 'http://localhost:8087')
LLAMA_API_URL = os.getenv('LLAMA_API_URL', 'http://localhost:11434')

# Initialize services (Singleton pattern)
category_manager = None
recommender = None


def init_services():
    """Initialize services with error handling"""
    global recommender, db_manager
    
    if recommender is not None:
        return
    
    try:
        logger.info("üöÄ Initializing services...")
        
        recommender = HybridRecommender(
            db_path=Config.DB_PATH,
            qdrant_host=Config.QDRANT_HOST,
            qdrant_port=Config.QDRANT_PORT
        )
        
        db_manager = DatabaseManager(Config.DB_PATH)
        
        logger.info("‚úÖ Services initialized successfully")
        
    except Exception as e:
        logger.error(f"‚ùå Service initialization failed: {e}")
        import traceback
        traceback.print_exc()
        recommender = None
        db_manager = None

@app.before_request
def before_request():
    """Initialize services before handling requests"""
    try:
        init_services()
    except Exception as e:
        logger.error(f"Service initialization error: {e}")


# ============================================================
# ENDPOINTS
# ============================================================


@app.route('/health', methods=['GET'])
def health():
    """Health check endpoint"""
    try:
        status = {
            'status': 'healthy',
            'timestamp': datetime.now().isoformat(),
            'services': {
                'api': 'operational'
            }
        }
        
        if recommender is None:
            status['status'] = 'degraded'
            status['services']['recommender'] = 'failed'
            status['error'] = 'Recommender service failed to initialize'
            return jsonify(status), 503
        
        status['services']['recommender'] = 'operational'
        status['services']['database'] = 'operational' if db_manager else 'unavailable'
        
        return jsonify(status), 200
        
    except Exception as e:
        return jsonify({
            'status': 'unhealthy',
            'error': str(e),
            'timestamp': datetime.now().isoformat()
        }), 500

@app.route('/api/user/onboard', methods=['POST'])
def user_onboarding():
    """
    New user onboarding with 3 interests
    
    Request:
    {
        "user_id": "user_123",
        "interests": ["movies", "sports", "technology"]
    }
    """
    try:
        data = request.get_json()
        
        user_id = data.get('user_id')
        interests = data.get('interests', [])
        
        if not user_id:
            return jsonify({'error': 'user_id required'}), 400
        
        if len(interests) != 3:
            return jsonify({'error': 'Exactly 3 interests required'}), 400
        
        # Create user profile
        result = recommender.create_user_profile(user_id, interests)
        
        # Get initial recommendations based on interests
        recommendations, metadata = recommender.recommend(
            user_id=user_id,
            query=None,
            limit=10
        )
        
        return jsonify({
            'status': 'success',
            'user': result,
            'initial_recommendations': recommendations,
            'metadata': metadata
        })
    
    except Exception as e:
        logger.error(f"‚ùå Onboarding error: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/recommend', methods=['POST'])
def recommend():
    """Get recommendations for a user"""
    try:
        if recommender is None:
            return jsonify({'error': 'Recommender service not available'}), 503
        
        data = request.json
        user_id = data.get('user_id')
        n_recommendations = data.get('n', Config.DEFAULT_RECOMMENDATIONS)
        
        if not user_id:
            return jsonify({'error': 'user_id is required'}), 400
        
        recommendations = recommender.get_recommendations(user_id, n_recommendations)
        
        return jsonify({
            'user_id': user_id,
            'recommendations': recommendations,
            'count': len(recommendations)
        }), 200
        
    except Exception as e:
        logger.error(f"Recommendation error: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/track', methods=['POST'])
def track_interaction():
    """
    Track user interaction
    
    Request:
    {
        "user_id": "user_123",
        "post_id": "post_456",
        "action": "like"  // view, click, like, share
    }
    """
    try:
        data = request.get_json()
        
        user_id = data.get('user_id')
        post_id = data.get('post_id')
        action = data.get('action', 'view')
        
        if not user_id or not post_id:
            return jsonify({'error': 'user_id and post_id required'}), 400
        
        # Track interaction
        recommender.track_interaction(user_id, post_id, action)
        
        return jsonify({
            'status': 'success',
            'message': f'Tracked {action} for {post_id}'
        })
    
    except Exception as e:
        logger.error(f"‚ùå Tracking error: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/user/<user_id>/interests', methods=['GET'])
def get_user_interests(user_id):
    """Get user's current interests"""
    try:
        interests = recommender.get_user_interests(user_id)
        
        return jsonify({
            'status': 'success',
            'user_id': user_id,
            'interests': interests
        })
    
    except Exception as e:
        logger.error(f"‚ùå Get interests error: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/categories', methods=['GET'])
def get_categories():
    """Get all available categories"""
    try:
        categories = category_manager.get_all_categories()
        
        return jsonify({
            'status': 'success',
            'categories': categories
        })
    
    except Exception as e:
        logger.error(f"‚ùå Get categories error: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/category/<category_name>/posts', methods=['GET'])
def get_category_posts(category_name):
    """Get top posts for a specific category"""
    try:
        limit = int(request.args.get('limit', 10))
        min_score = float(request.args.get('min_score', 0.5))
        
        posts = category_manager.get_category_top_posts(
            category=category_name,
            limit=limit,
            min_score=min_score
        )
        
        return jsonify({
            'status': 'success',
            'category': category_name,
            'posts': posts
        })
    
    except Exception as e:
        logger.error(f"‚ùå Get category posts error: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/train', methods=['POST'])
def train_categories():
    """
    Admin endpoint to train categories from dataset
    
    Request:
    {
        "dataset_path": "data/llama_dataset.json"
    }
    """
    try:
        data = request.get_json()
        dataset_path = data.get('dataset_path', 'data/llama_dataset.json')
        
        # Train categories (this may take time)
        category_manager.train_categories_from_dataset(dataset_path)
        
        return jsonify({
            'status': 'success',
            'message': f'Categories trained from {dataset_path}'
        })
    
    except Exception as e:
        logger.error(f"‚ùå Training error: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/search', methods=['GET'])
def search():
    """
    Search posts with category detection
    
    GET /api/search?q=best movies 2024&user_id=user_123&limit=10
    """
    try:
        query = request.args.get('q')
        user_id = request.args.get('user_id')
        limit = int(request.args.get('limit', 10))
        
        if not query:
            return jsonify({'error': 'query (q) required'}), 400
        
        # Detect categories from query
        detected_categories = category_manager.detect_query_category(query)
        
        # Get recommendations based on query
        if user_id:
            recommendations, metadata = recommender.recommend(
                user_id=user_id,
                query=query,
                limit=limit
            )
        else:
            # Anonymous search - just use category top posts
            if detected_categories:
                top_category = detected_categories[0]['category']
                recommendations = category_manager.get_category_top_posts(
                    category=top_category,
                    limit=limit
                )
                metadata = {
                    'detected_categories': detected_categories,
                    'search_type': 'anonymous'
                }
            else:
                recommendations = []
                metadata = {'error': 'No categories detected'}
        
        return jsonify({
            'status': 'success',
            'query': query,
            'detected_categories': detected_categories,
            'results': recommendations,
            'metadata': metadata
        })
    
    except Exception as e:
        logger.error(f"‚ùå Search error: {e}")
        return jsonify({'error': str(e)}), 500

# app.py - Add this endpoint for creating posts with auto-training

@app.route('/api/posts/create', methods=['POST'])
def create_post():
    """
    Create new post and train it immediately
    
    Request:
    {
        "user_id": "user_123",
        "title": "Best Action Movies 2024",
        "body": "Amazing action films with great stunts...",
        "category": "movies"  // Optional, LLaMA will detect if not provided
    }
    """
    try:
        data = request.get_json()
        
        user_id = data.get('user_id')
        title = data.get('title')
        body = data.get('body')
        declared_category = data.get('category')
        
        if not user_id or not title or not body:
            return jsonify({'error': 'user_id, title, and body required'}), 400
        
        # 1. Create post in MongoDB
        post = {
            'title': title,
            'body': body,
            'category': declared_category or 'general',
            'author_id': user_id,
            'created_at': datetime.now(),
            'likes': 0,
            'views': 0
        }
        
        result = recommender.posts_collection.insert_one(post)
        post_id = str(result.inserted_id)
        
        logger.info(f"‚úÖ Post created: {post_id}")
        
        # 2. Auto-detect category using LLaMA (if not provided)
        if not declared_category:
            detected = category_manager.detect_query_category(f"{title} {body}")
            if detected:
                detected_category = detected[0]['category']
                
                # Update post with detected category
                recommender.posts_collection.update_one(
                    {'_id': result.inserted_id},
                    {'$set': {'category': detected_category}}
                )
                
                post['category'] = detected_category
                logger.info(f"üéØ Auto-detected category: {detected_category}")
        
        # 3. Train this post immediately (generate category scores)
        logger.info(f"ü§ñ Training post: {post_id}")
        category_manager._train_single_post({
            '_id': result.inserted_id,
            **post
        })
        
        # 4. Create embedding for semantic search
        full_text = f"{title} {body}"
        embedding = recommender.embedding_model.encode(
            full_text,
            normalize_embeddings=True
        )
        
        # 5. Store in Qdrant
        from qdrant_client.models import PointStruct
        
        recommender.qdrant_client.upsert(
            collection_name=recommender.collection_name,
            points=[
                PointStruct(
                    id=post_id,
                    vector=embedding.tolist(),
                    payload={
                        'title': title,
                        'category': post['category'],
                        'author_id': user_id
                    }
                )
            ]
        )
        
        logger.info(f"üíæ Embedding stored in Qdrant")
        
        # 6. Send to Gorse (optional)
        try:
            import requests
            gorse_url = f"{recommender.gorse_api_url}/api/item"
            gorse_data = {
                "ItemId": post_id,
                "Categories": [post['category']],
                "Labels": [user_id]
            }
            requests.post(gorse_url, json=gorse_data, timeout=2)
            logger.info(f"üìä Sent to Gorse")
        except:
            pass
        
        return jsonify({
            'status': 'success',
            'post_id': post_id,
            'detected_category': post['category'],
            'message': 'Post created and trained successfully'
        })
    
    except Exception as e:
        logger.error(f"‚ùå Create post error: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/retrain', methods=['POST'])
def retrain_all_posts():
    """
    Admin endpoint to retrain all posts
    Use this when you update category keywords or LLaMA model
    """
    try:
        # Train from MongoDB directly (no JSON needed)
        category_manager.train_categories_from_mongodb(
            skip_already_trained=False  # Retrain everything
        )
        
        return jsonify({
            'status': 'success',
            'message': 'All posts retrained successfully'
        })
    
    except Exception as e:
        logger.error(f"‚ùå Retrain error: {e}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/admin/train-new', methods=['POST'])
def train_new_posts():
    """
    Train only new posts that haven't been trained yet
    Call this periodically (e.g., via cron job)
    """
    try:
        category_manager.train_new_posts_only()
        
        return jsonify({
            'status': 'success',
            'message': 'New posts trained successfully'
        })
    
    except Exception as e:
        logger.error(f"‚ùå Train new posts error: {e}")
        return jsonify({'error': str(e)}), 500

# ============================================================
# ERROR HANDLERS
# ============================================================

@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Endpoint not found'}), 404


@app.errorhandler(500)
def internal_error(error):
    return jsonify({'error': 'Internal server error'}), 500


# ============================================================
# MAIN
# ============================================================

if __name__ == '__main__':
    logger.info("üöÄ Starting Flask Recommendation API on http://localhost:5000")
    logger.info(f"   MongoDB: {MONGO_DB}")
    logger.info(f"   Gorse: {GORSE_API_URL}")
    logger.info(f"   LLaMA: {LLAMA_API_URL}")
    
    app.run(
        host='127.0.0.1',
        port=5000,
        debug= True
    )